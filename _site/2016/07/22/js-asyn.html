<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<base href="http://zhishan33.github.io/shanBlog/" />
		<!--<link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" />-->
		<!--<link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" />-->
		<link rel="stylesheet" type="text/css" href="/shanBlog/stylesheets/stylesheet.css" media="screen">
		<link rel="stylesheet" type="text/css" href="/shanBlog/stylesheets/github-light.css" media="screen">
		<!--<link rel="stylesheet" type="text/css" href="../css/base.css" />-->
		<title>js中ajax的异步执行与同步执行</title>
	</head>

	<body>
		<!--<section class="page-header">
			<h1 class="project-name">Shanblog</h1>
			<h2 class="project-tagline">Front end Engineer</h2>
			<a href="https://github.com/zhishan33/shanBlog" class="btn">View on GitHub</a>
			<a href="https://github.com/zhishan33/shanBlog/zipball/master" class="btn">Download .zip</a>
			<a href="https://github.com/zhishan33/shanBlog/tarball/master" class="btn">Download .tar.gz</a>
		</section>-->
		<section class="page-header">
	<h1 class="project-name">Shanblog</h1>
	<h2 class="project-tagline">Front end Engineer</h2>
	<a href="https://github.com/zhishan33/shanBlog" class="btn">View on GitHub</a>
	<a href="https://github.com/zhishan33/shanBlog/zipball/master" class="btn">Download .zip</a>
	<a href="https://github.com/zhishan33/shanBlog/tarball/master" class="btn">Download .tar.gz</a>
</section>
		<p>#js中ajax的异步执行与同步执行</p>

<p>@(笔记)[ajax]</p>

<p>##工作中的问题</p>

<blockquote>
  <p>在循环之前给元素标记一种状态，然后执行循环体每一次循环都有一次<strong>ajax</strong>请求，循环结束之后恢复元素状态。</p>
</blockquote>

<p>###代码块</p>
<blockquote>
  <p>html</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;ul&gt;
	&lt;li&gt;&lt;button id="getinfo"&gt;获取信息&lt;/button&gt;&lt;/li&gt;
	&lt;li&gt;&lt;button id="getnext"&gt;获取下一个&lt;/button&gt;&lt;/li&gt;
	&lt;li id="info"&gt;
		&lt;p&gt;信息替换&lt;/p&gt;
		&lt;p&gt;信息替换&lt;/p&gt;
		&lt;p&gt;信息替换&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</div>

<blockquote>
  <p><strong>循环开始之前运行的方法</strong></p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>function ajaxStart() {
	console.log("ajaxStart");
	$("#getnext").html("获取中。。。");
} &gt;**循环体** ajax同步

function ajaxMain() {
	$('p').each(function() {
		//setTimeout(function() {
			$.ajax({
				type: "get",
				url: "../json/js_asyn.json",
				async: false,
				success: function(data) {
					console.log('ajaxMain');
				}
			});
		//}, 2000);
	});
} &gt;**循环结束** 

function ajaxEnd() {
	console.log('ajaxEnd');
	$("#getnext").html("获取成功");
} &gt;**执行代码**

$("#getnext").click(function() {
	ajaxStart();
	ajaxMain();
	ajaxEnd();
}); &gt;输出结果   UI渲染过程的效果不明显 ，**实际上UI渲染被阻塞$('getnext').html('获取中。。。')不能及时更新，而是等待ajaxMain函数打印完结果后再执行。必须让ajaxMain延时执行，UI才能及时更新，$('getnext').html('获取中。。。')可立即执行，同时ajaxEnd也会跟着执行。最后执行ajaxMain。**

"ajaxStart"	
"ajaxMain"	
"ajaxMain"	
"ajaxMain"
"ajaxEnd"	 &gt;如果ajax异步   输出结果   UI渲染过程的效果不明显

"ajaxStart"	
"ajaxEnd"	
"ajaxMain"	
"ajaxMain"	
"ajaxMain"
</code></pre>
</div>

<blockquote>
  <p>如果ajax延时2s执行  输出结果</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>"ajaxStart"	
"ajaxEnd"	
"ajaxMain"	
"ajaxMain"	
"ajaxMain"
</code></pre>
</div>

<blockquote>
  <p>如何才能在ajaxMain全部执行完之后再执行ajaxEnd？直接把ajaxEnd放到ajax成功时的代码内，肯定不行，第一次成功就会执行ajaxEnd，必须在每一次成功时记录一次状态，并在下一次成功时获取这个状态，直到传递到最后一个ajax成功时再执行ajaxEnd。</p>
</blockquote>

<hr />
<blockquote>
  <p><strong>最后ajaxMian</strong></p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>function ajaxMain() {
	var num = 0;
	var plen = $("p").length;
	$('p').each(function() {
		var self = $(this);
		setTimeout(function() {
			$.ajax({
				type: "get",
				url: "../json/js_asyn.json",
				async: false,
				success: function(data) {
					console.log('ajaxMain');
					self.html('替换成功');
					num = ++num;
					if (num = plen) {
						ajaxEnd();
					}
				}
			});
		}, 200);
	});
}
</code></pre>
</div>

<p>##参考了以下代码，复习了ajax同步异步编程知识</p>

<p>###代码块</p>
<blockquote>
  <p>html</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;div id="output"&gt;&lt;/div&gt;
&lt;button onclick="updateSync ()"&gt;Run Sync&lt;/button&gt;
&lt;button onclick="updateAsync ()"&gt;Run Async&lt;/button&gt; &gt;js

function updateSync() {

    for (var i = 0; i &lt; 1000; i++) {
        document.getElementById('output').innerHTML = i;
    }
    
}
function updateAsync() {

    var i = 0;
    function updateLater() {
        document.getElementById('output').innerHTML = (i++);
        if (i &lt; 1000) {
            setTimeout(updateLater, 0);
        }
    }
    updateLater();
    
}
</code></pre>
</div>

<blockquote>
  <p>由于js是单线程的所以运行updateSync函数导致UI更新被阻塞，setTimeout让updateLater函数异步执行，可以看到看到UI界面上从0到999快速地更新过程。</p>
</blockquote>

<p>###代码块
	function synchronizedCode() {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    var last = new Date().getTime();
    var count = 0;
    while (true) {
        var now = new Date().getTime();
        if (now - last &gt; 1000 * 2) {
            last = now;
            count++;
            console.log('the '+count+'th count');
        }
        if (count &gt; 5) {
            console.log('exist while.');
            break;
        }
    }
    
}

(function() {

    setTimeout(function() {console.log('setTimeout 0 occured first.');},0);
    setTimeout(function() {console.log('setTimeout 0 occured second.');},0);
    
    synchronizedCode();
    
})();
</code></pre>
</div>

<p>###输出结果
	the 1th count.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>the 2th count.

the 3th count.

the 4th count.

the 5th count.

exist while.

setTimeout 0 occured first.

setTimeout 0 occured second.
</code></pre>
</div>

<blockquote>
  <p>使用setTimeout函数时，尽管延时为0，js的执行顺序还是发生了改变。</p>
</blockquote>

<p>##参考文件</p>
<ul>
  <li><a href="http://echizen.github.io/tech/2016/03-05-asynchronous">js中的异步执行时间探究</a></li>
  <li><a href="https://software.intel.com/zh-cn/articles/asynchronized-javascript-programming">JavaScript异步编程</a></li>
  <li><a href="http://blog.whyun.com/posts/js/">js异步之惑</a></li>
</ul>

<p>22 Jul 2016</p>

	</body>

</html>